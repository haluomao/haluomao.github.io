---
layout: post
title: 面试被问到的问题
category: tech
comments: false
---

##1、递归和循环实现的差别
- 通常递归的代码会比较简洁，循环实现比较复杂。
- 递归调用需要额外的时间和空间消耗：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而且往栈里压入数据和弹出数据都需要时间。
- 递归中有可能很多计算都是重复的，从而对性能产生负面影响。
- 除了效率问题，递归还可能引起**调用栈溢出**。

##2、线程安全和线程不安全
**线程安全就是说多线程访问同一代码，不会产生不确定的结果。编写线程安全的代码是低依靠线程同步。**


线程安全问题都是由全局变量及静态变量引起的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

首先要明白线程的工作原理，jvm有一个main   memory，而每个线程有自己的working   memory，一个线程对一个variable进行操作时，都要在自己的working   memory里面建立一个copy，操作完之后再写入main   memory。多个线程同时操作同一个variable，就可能会出现不可预知的结果。根据上面的解释，很容易想出相应的scenario。 

而用synchronized的关键是建立一个monitor，这个monitor可以是要修改的variable也可以其他你认为合适的object比如method，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完   load到workingmemory   －>   use&assign   －>   store到mainmemory   的过程，才会释放它得到的锁。这样就实现了所谓的线程安全。

Bloch 给出了描述五类线程安全性的分类方法：不可变、线程安全、有条件线程安全、线程兼容和线程对立。

1. 不可变的对象一定是线程安全的，并且永远也不需要额外的同步[1]  。因为一个不可变的对象只要构建正确，其外部可见状态永远也不会改变，永远也不会看到它处于不一致的状态。Java 类库中大多数基本数值类如 Integer 、 String 和 BigInteger 都是不可变的。

2. 线程安全的对象具有在上面“线程安全”一节中描述的属性 -- 由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要任何额外的同步。这种线程安全性保证是很严格的 -- 许多类，如 Hashtable 或者 Vector 都不能满足这种严格的定义。
3. 有条件的线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。
4. 线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。这可能意味着用一个 synchronized 块包围每一个方法调用，或者创建一个包装器对象，其中每一个方法都是同步的(就像 Collections.synchronizedList() 一样)。也可能意味着用 synchronized 块包围某些操作序列。
5. 线程对立类是那些不管是否调用了外部同步都不能在并发使用时安全地呈现的类。线程对立很少见，当类修改静态数据，而静态数据会影响在其他线程中执行的其他类的行为，这时通常会出现线程对立。线程对立类的一个例子是调用 System.setOut() 的类。

##3、为什么要用单例而不是静态方法？
单例就是我们运行的当前虚拟机中有且只有一个需要的对象，不存在重复。static是给类静态成员变量使用的，属于类的属性，一般是一些常量之类的东西。

- 从加载上来说对于类和对象之间，在类加载到内存时候静态成员变量就存在了，而对象还不存在。
- 静态对象只能调用静态方法和静态变量，如果全部搞成静态方法那么意味着其他成员变量都要是静态的，很不方便，如果一天不要单例了也不容易扩展，很麻烦。