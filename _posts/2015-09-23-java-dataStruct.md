---
layout: post
title: Hash 哈希的神奇之处
category: Algorithm
comments: false
---
### Hash散列为什么能提高检索速度？

众所周知，
有序数组存储数据，对数据的检索效率会很高，但是，插入和删除会有瓶颈产生。
链表存储数据，通常只能采用逐个比较的方法来检索数据（查找数据），但是，插入和删除的效率很高。

于是，将两者结合，取长补短，优势互补一下，就产生哈希散列这种存储方式。

具体是怎么样的呢？
我们可以理解成，在链表存储的基础上，对链表结构进行的一项改进。
我们将一个大的链表，拆散成几个或者几十个小的链表。
每个链表的表头，存放到一个数组里面。

采用Hash散列进行存储，主要就是为了提高检索速度。

### HashCode
我们按照什么规则来将一个大链表中的数据，分散存放到不同的链表中呢？ 
 
在计算机当中，肯定是要将规则数量化的，也就是说，这个规则，一定要是个数字，这样才比较好操作。  

比如，按照存放时间，每5分钟一个时间段，将相同时间段存放的数据，放到同一个链表里面；  
或者，将数据排序，每5个数据形成一个链表；
等等，还有好多可以想象得到的方法。

但是，这些方法都会存在一些不足之处。

如果存放的数据，都是整数就好了。
这样，我可以创建一个固定大小的数组，比如50个大小，然后，让数据（整数）对50进行取余运算，
然后，这些数据，自然就会被分成50个链表了，每个链表可以是无序的，反正链表要逐个比较进行查询。

如果，我一个有200个数据，分组后，平均每组也就4个数据，那么，链表比较，平均也就比较4次就好了。

但是，实际上，我们存放的数据，通常都不是整数。

所以，我们需要将数据对象映射成整数的一个算法。

HashCode方法，应运而生了。

每个数据对象，都会对应一个HashCode值，通过HashCode我们可以将对象分组存放到不同的队列里。
这样，在检索的时候，就可以减少比较次数。

### 与Hashtable检索性能相关的因素
三方面的因素：HashCode方法、数组的大小 以及 数据对象的数量。

1.如果数组大小为1，那和链表存储没有什么区别了，
而且，还多了一步计算HashCode的时间，所以，数组不能太小，太小查询费时间。

2.如果我只存放1个数据对象，数组又非常大，那么，数组所占的内存空间，就比数据对象占的空间还大，
这样，少量数据对象，巨大的数组，虽然能够使检索速度，但是，浪费了很多内存空间。

3.如果所有对象的HashCode值都是相同的数，
那么，无论数组有多大，这些数据都会保存到同一个链表里面，

一个好的HashCode算法，可以使存放的数据，有较好的分散性，
在实际的实现当中，HashSet和HashMap都对数据对象产生的HashCode进行了二次散列处理，
使得数据对象具有更好的分散性。