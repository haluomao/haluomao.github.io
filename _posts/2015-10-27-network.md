---
layout: post
title: 网络
category: Network
comments: false
--- 
###1. OSI七层模型和 TCP/IP参考模型：
 
![对比关系图](/images/201509/ositcpip2.jpg "对比关系图")

###2. 以下的应用程序中，基于TCP 协议的有？(多选)
A.PING  
B.TFTP  
C.TELNET  
D.FTP  
E.OSPF  
F.SNMP  
G.WWW  


-- CDG



###3. 下列网络层的协议有哪些？(多选)
A.IP  
B.ARP  
C.ICMP  
D.RARP  
-- ABCD

ARP是地址解析协议，用于从IP地址映射到物理地址。每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。

![31](/images/201510/TCPIP.jpg "协议分布")
![32](/images/201510/protocol.gif "协议分布")

###4. 以下有关TCP 滑动窗口机制描述正确的是？(多选)
A.在TCP 连接的两端分别有滑动窗口，控制接收和发送  
B.仅在TCP 连接的发送端有滑动窗口即可很好实现流量控制  
C.仅在TCP 连接的接收端有滑动窗口即可很好实现流量控制  
D.TCP 连接两端的滑动窗口大小可以自由调节，不必完全一致  
-- AD

###5. 判断两个IP地址是否属于同一个网段？

把IP地址和掩码做“与”运算，然后比较其结果，如果相同则属于同一个网段，如果不等，则不是同一个网段。

###6. 各类地址

A类IP地址由1B的网络地址和3B的主机地址组成，网络地址的最高位必须是“0”，即第一段数字范围为1~127. Internt有126个A类地址。

B类：最高位是“10”，即第一段数字范围为128~191。

C类：“110”，192~223. 每个C类地址可以连接254台主机（0和255不能用）。

D类：用于多点播送，“1110”，224~239。全零地址对应于当前主机，全1地址是当前子网的广播地址。

E类：11110开始，240~254.当做保留地址，仅作实验和开发用。

###7. NAT（网络地址转换）
将一个IP地址域映射到另一个IP地址域的技术（两个地址域处于不同的局域网）。P2P的连接就是基于这个。

PAT端口转换，指内部IP与内部全局IP一对多对应。

###8. netstat命令解析
TBC

###9. 网络中常见的ping命令基于什么协议？

ICMP Internet控制消息协议。

“Ping of Death”（死亡之Ping）攻击原理：如果ICMP数据包的尺寸超过64KB上限，主机就会出现内存分配错误，导致TCP/IP堆栈崩溃，导致主机死机。

###10、网络常识
TCP和UDP包头部结构中都不包含目标地址的IP，只在IP地址中才有。

在TCP/IP协议中，采用端口号来区分不同的应用进程。

到目前为止，已出现了三种类型的防火墙，即数据包过滤、代理防火墙、双穴主机防火墙。

默认端口对应：SSH——22、Telnet ——23、SMTP——25、 POP3——110、DNS——53.

集线器（Hub）是工作在物理层的网络设备，用于双绞线的连接和信号中继（将已衰减的信号再次放大使之传得更远）。

交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。

路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。

网络层的IP 协议是构成Internet 的基础。IP 协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。

传输层可选择TCP 或UDP 协议。  
- TCP 是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP 协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。  
- UDP 协议不面向连接，也不保证可靠性，有点像寄信，写好信放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件是按顺序寄到目的地的。使用UDP 协议的应用程序需要自己完成丢包重发、消息排序等工作。

###11、[报文头大小](http://blog.csdn.net/mrwangwang/article/details/8537775)

以太网 14B、IP层 20、 TCP层 20：

![3](/images/201510/ethernet.jpg "报文头大小")

不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。

####11.1 IP报文
![IP报文](/images/201510/ipv4.jpg "IP报文")

IP 数据报的首部长度和数据长度都是可变长的，但总是4 字节的整数倍。

对于IPv4，4 位版本字段是4。4 位首部长度的数值是以4 字节为单位的，最小值为5，也就是说首部长度最小是4x5=20 字节，也就是不带任何选项的IP 首部，4 位能表示的最大值是15，也就是说首部长度最大是60 字节。 8位TOS 字段有3 个位用来指定IP 数据报的优先级（目前已经废弃不用），还有4 个位表示可选的服务类型（最小延迟、最大呑吐量、最大可靠性、最小成本），还有一个位总是0。总长度是整个数据报（包括IP 首部和IP 层payload）的字节数。每传一个IP 数据报，16 位的标识加1，可用于分片和重新组装数据报。3 位标志和13 位片偏移用于分片。TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0 就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。协议字段指示上层协议是TCP、UDP、ICMP 还是IGMP。然后是校验和，只校验IP 首部，数据的校验由更高层协议负责。

IPv4的IP 地址长度为32 位。

####11.2 UDP段格式
![4](/images/201510/udp.jpg "UDP报文")
报头长度应该是8B。

####11.3 TCP段格式
![5](/images/201510/tcp.jpg "TCP报文")

###12、IPv6
IPv6是Internet Protocol Version 6的缩写。

我们使用的第二代互联网IPv4技术，核心技术属于美国。它的最大问题是网络地址资源有限，从理论上讲，编址1600万个网络、40亿台主机。但采用A、B、C三类编址方式后，可用的网络地址和主机地址的数目大打折扣，以至IP地址已于2011年2月3日分配完毕。

IPv6所拥有的地址容量是IPv4的约8×10^28倍，达到2^128（算上全零的）个。这不但解决了网络地址资源数量的问题，同时也为除电脑外的设备连入互联网在数量限制上扫清了障碍。

特点：
（1）IPV6地址长度为128位，地址空间增加了2^128-2^32个。  
（2）灵活的IP报文头部格式。使用一系列固定格式的扩展头部取代了IPV4中可变长度的选项字段。IPV6中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文处理速度；  
（3）IPV6简化了报文头部格式，字段只有8个，加快报文转发，提高了吞吐量；  
（4）提高安全性。身份认证和隐私权是IPV6的关键特性；  
（5）支持更多的服务类型；  
（6）允许协议继续演变，增加新的功能，使之适应未来技术的发展；

每段16位，分8段。

**FE80:0000:0000:0000:AAAA:0000:00C2:0002 是一个合法的IPv6地址。**

要是嫌这个地址看起来还是太长，这里还有种办法来缩减其长度，叫做**零压缩法**。如果几个连续段位的值都是0，那么这些0就可以简单的以::来表示，上述地址就可以写成`FE80::AAAA:0000:00C2:0002`。  
这里要注意的是只能简化连续的段位的0，其前后的0都要保留，比如FE80的最后的这个0，不能被简化。还有这个**只能用一次**，在上例中的AAAA后面的0000就不能再次简化。当然也可以在AAAA后面使用::，这样的话前面的12个0就不能压缩了。这个限制的目的是为了能准确还原被压缩的0.不然就无法确定每个::代表了多少个0.


###13、SYN Cookie

SYN Flood是一种非常危险而常见的Dos攻击方式。到目前为止，能够有效防范SYN Flood攻击的手段并不多，SYN Cookie就是其中最著名的一种。
**（SYN Cookie是防范SYN Flood攻击的技术）**

SYN Flood攻击利用的是IPv4中TCP协议的三次握手(Three-Way Handshake)过程进行的攻击。  
TCP服务器收到TCP SYN request包时，在发送TCP SYN + ACK包回客户机前，TCP服务器要先分配好一个数据区专门
服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半打开连接(Half-open Connection)。
在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者。受害者(服务器)为每个TCP SYN包分配
一个特定的数据区，只要这些SYN包具有不同的源地址(攻击者很容易伪造)。这将给TCP服务器造成很大的系统负担，最终导致系统不能正常工作。

SYN Flood它的原理是，在TCP服务器
接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。

###14、 TCP的三次握手，为什么要3次？
建立连接的过程是利用客户服务器模式，假设主机 A 为客户端，主机 B 为服务器端。

（ 1 ） TCP 的三次握手过程：主机 A 向 B 发送连接请求；主机 B 对收到的主机 A 的报文段进行确认；主机 A 再次对主机 B 的确认进行确认。

（ 2 ）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机 B ，因而产生错误（**防止已过期的连接再次传到被连接的主机**）。失效的连接请求报文段是指：主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B ，主机 B 以为是主机 A 又发起的新连接，于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费。

（ 3 ）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。三次握手改成仅需要两次握手，死锁是可能发生。

考虑计算机A和B之间的通信，假定B给A发送一个连接请求分组，A收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A认为连接已经成功地建立了，可以开始发送数据分组。可是，B在A的应答分组在传输中被丢失的情况下，将不知道A是否已准备好，不知道A建议什么样的序列号，B甚至怀疑A是否收到自己的连接请求分组。在这种情况下，B认为连接还未建立成功，将忽略A发来的任何数据分组，只等待连接确认应答分组。而A在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。
